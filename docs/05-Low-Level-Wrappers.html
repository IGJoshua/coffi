<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Low-Level Wrappers</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">coffi</span> <span class="project-version">v1.0.486</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-Getting-Started.html"><div class="inner"><span>Getting Started</span></div></a></li><li class="depth-1 "><a href="02-Memory-Management.html"><div class="inner"><span>Memory Management</span></div></a></li><li class="depth-1 "><a href="03-Builtin-Types.html"><div class="inner"><span>Built-in Types</span></div></a></li><li class="depth-1 "><a href="04-Custom-Types.html"><div class="inner"><span>Custom Types</span></div></a></li><li class="depth-1  current"><a href="05-Low-Level-Wrappers.html"><div class="inner"><span>Low-Level Wrappers</span></div></a></li><li class="depth-1 "><a href="50-Data-Model.html"><div class="inner"><span>Data Model</span></div></a></li><li class="depth-1 "><a href="99-Benchmarks.html"><div class="inner"><span>Benchmarks</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coffi</span></div></div></li><li class="depth-2 branch"><a href="coffi.ffi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ffi</span></div></a></li><li class="depth-2 branch"><a href="coffi.layout.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>layout</span></div></a></li><li class="depth-2"><a href="coffi.mem.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mem</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#low-level-wrappers" id="low-level-wrappers"></a>Low-Level Wrappers</h1>
<h3><a href="#unwrapped-native-handles" id="unwrapped-native-handles"></a>Unwrapped Native Handles</h3>
<p>Some native libraries work with handles to large amounts of data at once, making it undesirable to marshal data back and forth from Clojure, both because it’s not necessary to work with the data in Clojure directly, or also because of the high (de)serialization costs associated with marshaling. In cases like these, unwrapped native handles are desirable.</p>
<p>The functions <code>make-downcall</code> and <code>make-varargs-factory</code> are also provided to create raw function handles.</p>
<pre><code class="language-clojure">(def raw-strlen (ffi/make-downcall "strlen" [::mem/c-string] ::mem/long))
(raw-strlen (mem/serialize "hello" ::mem/c-string))
;; =&gt; 5
</code></pre>
<p>With raw handles, the argument types are expected to exactly match the types expected by the native function. For primitive types, those are primitives. For pointers, that is <code>MemorySegment</code>, and for composite types like structs and unions, that is also <code>MemorySegment</code>. <code>MemorySegment</code> comes from the <code>java.lang.foreign</code> package.</p>
<p>In addition, when a raw handle returns a composite type represented with a <code>MemorySegment</code>, it requires an additional first argument, a <code>SegmentAllocator</code>, which can be acquired with <code>arena-allocator</code> to get one associated with a specific arena. The returned value will live until that arena is released.</p>
<p>In addition, function types can be specified as being raw, in the following manner:</p>
<pre><code class="language-clojure">[::ffi/fn [::mem/int] ::mem/int :raw-fn? true]
</code></pre>
<p>Clojure functions serialized to this type will have their arguments and return value exactly match the types specified and will not perform any serialization or deserialization at their boundaries.</p>
<p>One important caveat to consider when writing wrappers for performance-sensitive functions is that the convenience macro <code>defcfn</code> that coffi provides will already perform no serialization or deserialization on primitive arguments and return types, so for functions with only primitive argument and return types there is no performance reason to choose unwrapped native handles over the convenience macro.</p>
<h3><a href="#manual-deserialization" id="manual-deserialization"></a>Manual (De)Serialization</h3>
<p>Coffi uses multimethods to dispatch to (de)serialization functions to enable code that’s generic over the types it operates on. However, in cases where you know the exact types that you will be (de)serializing and the multimethod dispatch overhead is too high a cost, it may be appropriate to manually handle (de)serializing data. This will often be done paired with <a href="#unwrapped-native-handles">Unwrapped Native Handles</a>.</p>
<p>Convenience functions are provided to both read and write all primitive types and addresses, including byte order.</p>
<p>As an example, when wrapping a function that returns an array of big-endian floats, the following code might be used.</p>
<pre><code class="language-clojure">;; int returns_float_array(float **arr)
(def ^:private returns-float-array* (ffi/make-downcall "returns_float_array" [::mem/pointer] ::mem/int))
;; void releases_float_array(float *arr)
(def ^:private release-floats* (ffi/make-downcall "releases_float_array" [::mem/pointer] ::mem/void))

(defn returns-float-array
  []
  (with-open [arena (mem/confined-arena)]
    ;; float *out_floats;
    ;; int num_floats = returns_float_array(&amp;out_floats);
    (let [out-floats (mem/alloc mem/pointer-size arena)
          num-floats (returns-float-array* out-floats)
          floats-addr (mem/read-address out-floats)
          floats-slice (mem/reinterpret floats-addr (unchecked-multiply-int mem/float-size num-floats))]
      ;; Using a try/finally to perform an operation when the stack frame exits,
      ;; but not to try to catch anything.
      (try
        (loop [floats (transient [])
               index 0]
          (if (&gt;= index num-floats)
            (persistent! floats)
            (recur (conj! floats (mem/read-float floats-slice
                                                 (unchecked-multiply-int index mem/float-size)
                                                 mem/big-endian))
                   (unchecked-inc-int index))))
        (finally
          (release-floats* floats-addr))))))
</code></pre>
<p>The above code manually performs all memory operations rather than relying on coffi’s dispatch. This will be more performant, but because multimethod overhead is usually relatively low, it’s recommended to use the multimethod variants for convenience in colder functions.</p>
</div></div></div></body></html>