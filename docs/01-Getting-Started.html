<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Getting Started</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">coffi</span> <span class="project-version">v1.0.486</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="01-Getting-Started.html"><div class="inner"><span>Getting Started</span></div></a></li><li class="depth-1 "><a href="02-Memory-Management.html"><div class="inner"><span>Memory Management</span></div></a></li><li class="depth-1 "><a href="03-Builtin-Types.html"><div class="inner"><span>Built-in Types **WIP**</span></div></a></li><li class="depth-1 "><a href="04-Custom-Types.html"><div class="inner"><span>Custom Types</span></div></a></li><li class="depth-1 "><a href="05-Low-Level-Wrappers.html"><div class="inner"><span>Low-Level Wrappers</span></div></a></li><li class="depth-1 "><a href="50-Data-Model.html"><div class="inner"><span>Data Model</span></div></a></li><li class="depth-1 "><a href="99-Benchmarks.html"><div class="inner"><span>Benchmarks **OUTDATED**</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coffi</span></div></div></li><li class="depth-2 branch"><a href="coffi.ffi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ffi</span></div></a></li><li class="depth-2 branch"><a href="coffi.layout.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>layout</span></div></a></li><li class="depth-2"><a href="coffi.mem.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mem</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#getting-started" id="getting-started"></a>Getting Started</h1>
<h2><a href="#installation" id="installation"></a>Installation</h2>
<p>This library is available on Clojars. Add one of the following entries to the <code>:deps</code> key of your <code>deps.edn</code>:</p>
<pre><code class="language-clojure">org.suskalo/coffi {:mvn/version "x.y.z"}
io.github.IGJoshua/coffi {:git/tag "x.y.z" :git/sha "abcdef0"}
</code></pre>
<p>See GitHub for the <a href="https://github.com/IGJoshua/coffi/releases">latest releases</a>.</p>
<p>If you use this library as a git dependency, you will need to prepare the library.</p>
<pre><code class="language-sh">$ clj -X:deps prep
</code></pre>
<p>Coffi requires usage of the package <code>java.lang.foreign</code>, and most of the operations are considered unsafe by the JDK, and are therefore unavailable to your code without passing some command line flags. In order to use coffi, add the following JVM arguments to your application.</p>
<pre><code class="language-sh">--enable-native-access=ALL-UNNAMED
</code></pre>
<p>You can specify JVM arguments in a particular invocation of the Clojure CLI with the -J flag like so:</p>
<pre><code class="language-sh">clj -J--enable-native-access=ALL-UNNAMED
</code></pre>
<p>You can also specify them in an alias in your <code>deps.edn</code> file under the <code>:jvm-opts</code> key (see the next example) and then invoking the CLI with that alias using <code>-M</code>, <code>-A</code>, or <code>-X</code>.</p>
<pre><code class="language-clojure">{:aliases {:dev {:jvm-opts ["--enable-native-access=ALL-UNNAMED"]}}}
</code></pre>
<p>Other build tools should provide similar functionality if you check their documentation.</p>
<p>When creating an executable jar file, you can avoid the need to pass this argument by adding the manifest attribute <code>Enable-Native-Access: ALL-UNNAMED</code> to your jar.</p>
<h2><a href="#basic-usage" id="basic-usage"></a>Basic Usage</h2>
<p>There are two major components to coffi and interacting with native code: manipulating off-heap memory, and loading native code for use with Clojure.</p>
<p>In the simplest cases, the native functions you call will work exclusively with built-in types, for example the function <code>strlen</code> from libc.</p>
<pre><code class="language-clojure">(require '[coffi.mem :as mem :refer [defalias]])
(require '[coffi.ffi :as ffi :refer [defcfn]])

(defcfn strlen
  "Given a string, measures its length in bytes."
  strlen [::mem/c-string] ::mem/long)

(strlen "hello")
;; =&gt; 5
</code></pre>
<p>The first argument to <code>defcfn</code> is the name of the Clojure var that will hold the native function reference, followed by an optional docstring and attribute map, then the C function identifier, including the name of the native symbol, a vector of argument types, and the return type.</p>
<p>If you wish to use a native function as an anonymous function, it can be done with the <code>cfn</code> function.</p>
<pre><code class="language-clojure">((ffi/cfn "strlen" [::mem/c-string] ::mem/long) "hello")
;; =&gt; 5
</code></pre>
<p>If you want to use functions from libraries other than libc, then you’ll need to load them. Two functions are provided for this, <code>load-system-library</code>, and <code>load-library</code>. <code>load-system-library</code> takes a string which represents the name of a library that should be loaded via system lookup.</p>
<pre><code class="language-clojure">(ffi/load-system-library "z")
</code></pre>
<p>This will load libz from the appropriate place on the user’s load path.</p>
<p>Alternatively, <code>load-library</code> takes a file path to a dynamically loaded library.</p>
<pre><code class="language-clojure">(ffi/load-library "lib/libz.so")
</code></pre>
<p>This will load libz from the lib subdirectory of the current working directory. As you can see this requires the entire filename, including platform-specific file extensions.</p>
<p>If a library is attempted to be loaded but doesn’t exist or otherwise can’t be loaded, an exception is thrown. This can be convenient as any namespace with a <code>load-library</code> call at the top level cannot be required without the library being able to be loaded.</p>
<h3><a href="#primitive-types" id="primitive-types"></a>Primitive Types</h3>
<p>Coffi defines a basic set of primitive types:</p>
<ul>
<li>byte</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>char</li>
<li>float</li>
<li>double</li>
<li>pointer</li>
</ul>
<p>Each of these types maps to their C counterpart. Values of any of these primitive types except for <code>pointer</code> will be cast with their corresponding Clojure function when they are passed as arguments to native functions. Additionally, the <code>c-string</code> type is defined, although it is not primitive.</p>
<h3><a href="#composite-types" id="composite-types"></a>Composite Types</h3>
<p>In addition, some composite types are also defined in coffi, including struct and union types (unions will be discussed with serialization and deserialization). For an example C struct and function:</p>
<pre><code class="language-c">typedef struct point {
    float x;
    float y;
} Point;

Point zero(void) {
    Point res = {};

    res.x = 0.0;
    res.y = 0.0;

    return res;
}
</code></pre>
<p>The corresponding coffi definition is like so:</p>
<pre><code class="language-clojure">(defcfn zero-point
  "zero" [] [::mem/struct [[:x ::mem/float] [:y ::mem/float]]])

(zero-point)
;; =&gt; {:x 0.0,
;;     :y 0.0}
</code></pre>
<p>Writing out struct definitions like this every time would get tedious, so the macro <code>defalias</code> is used to define a struct alias.</p>
<pre><code class="language-clojure">(defalias ::point
  [::mem/struct
   [[:x ::mem/float]
    [:y ::mem/float]]])

(defcfn zero-point
  "zero" [] ::point)
</code></pre>
<p>Struct definitions do not include any padding by default. Functions for transforming struct types to include padding conforming to various standards can be found in <code>coffi.layout</code>.</p>
<pre><code class="language-clojure">(require '[coffi.layout :as layout])

(defalias ::needs-padding
  (layout/with-c-layout
   [::mem/struct
    [[:a ::mem/char]
     [:x ::mem/float]]]))

(mem/size-of ::needs-padding)
;; =&gt; 8

(mem/align-of ::needs-padding)
;; =&gt; 4
</code></pre>
<p>Values deserialized with types produced from layout functions may include an extra <code>:coffi.layout/padding</code> key with a nil value.</p>
<p>A limitation of the <code>defcfn</code> macro in its current form is that types provided to it must be provided in a literal form, not as an expression that evaluates to a type. This means that if you wish to use a layout function on a struct you must define an alias for it before the type can be used as a type in <code>defcfn</code>.</p>
<p>In cases where a pointer to some data is required to pass as an argument to a native function, but doesn’t need to be read back in, the <code>pointer</code> primitive type can take a type argument.</p>
<pre><code class="language-clojure">[::mem/pointer ::mem/int]
</code></pre>
<p>Arrays are also supported via a type argument. Keep in mind that they are the array itself, and not a pointer to the array like you might see in certain cases in C.</p>
<pre><code class="language-clojure">[::mem/array ::mem/int 3]
</code></pre>
<h3><a href="#callbacks" id="callbacks"></a>Callbacks</h3>
<p>In addition to these composite types, there is also support for Clojure functions.</p>
<pre><code class="language-clojure">[::ffi/fn [::mem/c-string] ::mem/int]
</code></pre>
<p>Be aware though that if an exception is thrown out of a callback that is called from C, the JVM will crash. The resulting crash log should include the exception type and message in the registers section, but it’s important to be aware of all the same. Ideally you should test your callbacks before actually passing them to native code.</p>
<p>When writing a wrapper library for a C library, it may be a good choice to wrap all passed Clojure functions in an additional function which catches all throwables, potentially notifies the user in some manner (e.g. logging), and returns a default value. This is on the wrapper library’s developer to decide when and where this is appropriate, as in some cases no reasonable default return value can be determined and it is most sensible to simply crash the JVM. This is the reason that coffi defaults to this behavior, as in the author’s opinion it is better to fail hard and fast rather than to attempt to produce a default and cause unexpected behavior later.</p>
<p>Another important thing to keep in mind is the expected lifetime of the function that you pass to native code. For example it is perfectly fine to pass an anonymous function to a native function if the callback will never be called again once the native function returns. If however it saves the callback for later use the JVM may collect it prematurely, causing a crash when the callback is later called by native code.</p>
<h3><a href="#variadic-functions" id="variadic-functions"></a>Variadic Functions</h3>
<p>Some native functions can take any number of arguments, and in these cases coffi provides <code>vacfn-factory</code> (for “varargs C function factory”).</p>
<pre><code class="language-clojure">(def printf-factory (ffi/vacfn-factory "printf" [::mem/c-string] ::mem/int))
</code></pre>
<p>This returns a function of the types of the rest of the arguments which itself returns a native function wrapper.</p>
<pre><code class="language-clojure">(def print-int (printf-factory ::mem/int))

(print-int "Some integer: %d\n" 5)
;; Some integer: 5
</code></pre>
<p>At the moment there is no equivalent to <code>defcfn</code> for varargs functions.</p>
<p>Some native functions that are variadic use the type <code>va_list</code> to make it easier for other languages to call them in their FFI. At the time of writing, coffi does not support va-list, however it is a planned feature.</p>
<h3><a href="#global-variables" id="global-variables"></a>Global Variables</h3>
<p>Some libraries include global variables or constants accessible through symbols. To start with, constant values stored in symbols can be fetched with <code>const</code>, or the parallel macro <code>defconst</code></p>
<pre><code class="language-clojure">(def some-const (ffi/const "some_const" ::mem/int))
(ffi/defconst some-const "some_const" ::mem/int)
</code></pre>
<p>This value is fetched once when you call <code>const</code> and is turned into a Clojure value. If you need to refer to a global variable, then <code>static-variable</code> (or parallel <code>defvar</code>) can be used to create a reference to the native value.</p>
<pre><code class="language-clojure">(def some-var (ffi/static-variable "some_var" ::mem/int))
(ffi/defvar some-var "some_var" ::mem/int)
</code></pre>
<p>This variable is an <code>IDeref</code>. Each time you dereference it, the value will be deserialized from the native memory and returned. Additional functions are provided for mutating the variable.</p>
<pre><code class="language-clojure">(ffi/freset! some-var 5)
;; =&gt; 5
@some-var
;; =&gt; 5
</code></pre>
<p>Be aware however that there is no synchronization on these types. The value being read is not read atomically, so you may see an inconsistent state if the value is being mutated on another thread.</p>
<p>A parallel function <code>fswap!</code> is also provided, but it does not provide any atomic semantics either.</p>
<p>The memory that backs the static variable can be fetched with the function <code>static-variable-segment</code>, which can be used to pass a pointer to the static variable to native functions that require it.</p>
<h3><a href="#complex-wrappers" id="complex-wrappers"></a>Complex Wrappers</h3>
<p>Some functions require more complex code to map nicely to a Clojure function. The <code>defcfn</code> macro provides facilities to wrap the native function with some Clojure code to make this easier.</p>
<pre><code class="language-clojure">(defcfn takes-array
  "takes_array_with_count" [::mem/pointer ::mem/long] ::mem/void
  native-fn
  [ints]
  (let [arr-len (count ints)
        int-array (mem/serialize ints [::mem/array ::mem/int arr-len])]
    (native-fn int-array arr-len)))
</code></pre>
<p>The symbol <code>native-fn</code> can be any unqualified symbol, and names the native function being wrapped. It must be called in the function body below if you want to call the native code.</p>
<p>This <code>serialize</code> function has a paired <code>deserialize</code>, and allows marshaling Clojure data back and forth to native data structures.</p>
<p>This can be used to implement out variables often seen in native code.</p>
<pre><code class="language-clojure">(defcfn out-int
  "out_int" [::mem/pointer] ::mem/void
  native-fn
  [i]
  (let [int-ptr (mem/serialize i [::mem/pointer ::mem/int])]
    (native-fn int-ptr)
    (mem/deserialize int-ptr [::mem/pointer ::mem/int])))
</code></pre>
</div></div></div></body></html>