<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Data Model</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">coffi</span> <span class="project-version">v1.0.486</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-Getting-Started.html"><div class="inner"><span>Getting Started</span></div></a></li><li class="depth-1 "><a href="02-Memory-Management.html"><div class="inner"><span>Memory Management</span></div></a></li><li class="depth-1 "><a href="03-Builtin-Types.html"><div class="inner"><span>Built-in Types</span></div></a></li><li class="depth-1 "><a href="04-Custom-Types.html"><div class="inner"><span>Custom Types</span></div></a></li><li class="depth-1 "><a href="05-Low-Level-Wrappers.html"><div class="inner"><span>Low-Level Wrappers</span></div></a></li><li class="depth-1  current"><a href="50-Data-Model.html"><div class="inner"><span>Data Model</span></div></a></li><li class="depth-1 "><a href="99-Benchmarks.html"><div class="inner"><span>Benchmarks</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coffi</span></div></div></li><li class="depth-2 branch"><a href="coffi.ffi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ffi</span></div></a></li><li class="depth-2 branch"><a href="coffi.layout.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>layout</span></div></a></li><li class="depth-2"><a href="coffi.mem.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mem</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#data-model" id="data-model"></a>Data Model</h1>
<p>In addition to the macros and functions provided to build a Clojure API for native libraries, facilities are provided for taking data and loading all the symbols specified by it. This can be useful if a library provides (or an external provider maintains) a data representation of their API, as Clojure data to represent it may be programmatically generated from these sources.</p>
<p>The data to represent an API is a map with the following form:</p>
<pre><code class="language-clojure">(def strlen-libspec
  {:strlen {:type :function
            :symbol "strlen"
            :function/args [::mem/c-string]
            :function/ret ::mem/long}})
</code></pre>
<p>Each key in this map represents a single symbol to be loaded. The value is a map with at least the keys <code>:type</code> and <code>:symbol</code>. These are the currently recognized types:</p>
<ul>
<li>function</li>
<li>varargs-factory</li>
<li>const</li>
<li>static-var</li>
</ul>
<p>Each one has its own set of additional keys which can be added to the map. Both <code>function</code> and <code>varargs-factory</code> have the three keys <code>:function/args</code>, <code>:function/ret</code>, and <code>:function/raw-fn?</code>. The <code>const</code> type has <code>:const/type</code> and <code>static-var</code> has <code>:static-var/type</code>.</p>
<p>This data can be passed to the function <code>reify-libspec</code>, which will take the data and return a map from the same keys as the input map to whatever value is appropriate for a given symbol type (e.g. a Clojure function for <code>function</code>, a value for <code>const</code>, etc.).</p>
<pre><code class="language-clojure">(ffi/reify-libspec strlen-libspec)
;; =&gt; {:strlen #function[...]}
</code></pre>
<p>This functionality can be extended by specifying new types as implementations of the multimethod <code>reify-symbolspec</code>, although itâ€™s recommended that for any library authors who do so, namespaced keywords be used to name types.</p>
</div></div></div></body></html>