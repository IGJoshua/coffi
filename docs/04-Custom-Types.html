<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Custom Types</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">coffi</span> <span class="project-version">v1.0.615</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="01-Getting-Started.html"><div class="inner"><span>Getting Started</span></div></a></li><li class="depth-1 "><a href="02-Memory-Management.html"><div class="inner"><span>Memory Management</span></div></a></li><li class="depth-1 "><a href="03-Builtin-Types.html"><div class="inner"><span>Built-in Types **WIP**</span></div></a></li><li class="depth-1  current"><a href="04-Custom-Types.html"><div class="inner"><span>Custom Types</span></div></a></li><li class="depth-1 "><a href="05-Low-Level-Wrappers.html"><div class="inner"><span>Low-Level Wrappers</span></div></a></li><li class="depth-1 "><a href="50-Data-Model.html"><div class="inner"><span>Data Model</span></div></a></li><li class="depth-1 "><a href="99-Benchmarks.html"><div class="inner"><span>Benchmarks **OUTDATED**</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>coffi</span></div></div></li><li class="depth-2 branch"><a href="coffi.ffi.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ffi</span></div></a></li><li class="depth-2 branch"><a href="coffi.layout.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>layout</span></div></a></li><li class="depth-2"><a href="coffi.mem.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mem</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#custom-types" id="custom-types"></a>Custom Types</h1>
<p>Custom types with serializers and deserializers may be created. This is done using two sets of three multimethods which can be extended by the user. For any given type, only one set need be implemented.</p>
<p>Two examples of custom types are given here, one is a 3d vector, and the other an example of a tagged union.</p>
<h3><a href="#vector3" id="vector3"></a>Vector3</h3>
<p>For the vector type, it will serialize to a pointer to an array of three floats.</p>
<p>The multimethod <code>primitive-type</code> returns the primitive type that a given type serializes to. For this example, it should be a pointer.</p>
<pre><code class="language-clojure">(defmethod mem/primitive-type ::vector
  [_type]
  ::mem/pointer)
</code></pre>
<p>For any type which doesn’t serialize to a primitive, it returns nil, and therefore need not be overriden.</p>
<p>Next is <code>serialize*</code> and <code>deserialize*</code>, multimethods that work with types that serialize to primitives.</p>
<pre><code class="language-clojure">(defmethod mem/serialize* ::vector
  [obj _type arena]
  (mem/serialize obj [::mem/array ::mem/float 3] arena))

(defmethod mem/deserialize* ::vector
  [segment _type]
  (mem/deserialize (mem/reinterpret segment (mem/size-of [::mem/array ::mem/float 3]))
                   [::mem/array ::mem/float 3]))
</code></pre>
<p>The <code>reinterpret</code> function allows you to take a segment and decorate it with a new size, and possibly associate it with an arena or add cleanup functions on it.</p>
<p>In cases like this where we don’t know the arena of the pointer, we could use <code>reinterpret</code> to ensure it’s freed. For example if a <code>free-vector!</code> function that takes a pointer exists, we could use this:</p>
<pre><code class="language-clojure">(defcfn returns-vector
  "returns_vector" [] ::mem/pointer
  native-fn
  [arena]
  (let [ret-ptr (native-fn)]
    (-&gt; (reinterpret ret-ptr (mem/size-of ::vector) arena free-vector!)
        (deserialize ::vector))))
</code></pre>
<p>This function takes an arena and returns the deserialized vector, and it will free the pointer when the arena closes.</p>
<h3><a href="#tagged-union" id="tagged-union"></a>Tagged Union</h3>
<p>For the tagged union type, we will represent the value as a vector of a keyword naming the tag and the value. The type itself will need to take arguments, similar to <code>struct</code>. For example, if we were to represent a result type like in Rust, we might have the following values:</p>
<pre><code class="language-clojure">[:ok 5]
[:err "Invalid number format"]
</code></pre>
<p>To represent this, we can have a <code>tagged-union</code> type. For this instance of the result type, it may look like this:</p>
<pre><code class="language-clojure">[::tagged-union [:ok :err] {:ok ::mem/int :err ::mem/c-string}]
</code></pre>
<p>The native representation of these objects is a struct of the tag and a union of the value. In order to correctly serialize the data and pass it to native code, we need a representation of the native layout of the data. The <code>c-layout</code> multimethod provides that.</p>
<pre><code class="language-clojure">(defmethod mem/c-layout ::tagged-union
  [[_tagged-union tags type-map]]
  (mem/c-layout [::mem/struct
                 [[:tag ::mem/long]
                  [:value [::mem/union (vals type-map)]]]]))
</code></pre>
<p>Types with type arguments are represented as vectors of the type name and any additional arguments. The type name is what is dispatched on for the multimethods.</p>
<p>Now that we have a native layout, we need to be able to serialize and deserialize the value into and out of memory segments. This is accomplished with <code>serialize-into</code> and <code>deserialize-from</code>.</p>
<pre><code class="language-clojure">(defn item-index
  "Gets the index of the first occurance of `item` in `coll`."
  [coll item]
  (first
   (-&gt;&gt; coll
        (map-indexed vector)
        (filter (comp #{item} second))
        (map first))))

(defmethod mem/serialize-into ::tagged-union
  [obj [_tagged-union tags type-map] segment arena]
  (mem/serialize-into
   {:tag (item-index tags (first obj))
    :value (second obj)}
   [::mem/struct
    [[:tag ::mem/long]
     [:value (get type-map (first obj))]]]
   segment
   arena))
</code></pre>
<p>This serialization method is rather simple, it just turns the vector value into a map, and serializes it as a struct, choosing the type of the value based on the tag.</p>
<pre><code class="language-clojure">(defmethod mem/deserialize-from ::tagged-union
  [segment [_tagged-union tags type-map]]
  (let [tag (mem/deserialize-from segment ::mem/long)]
    [(nth tags tag)
     (mem/deserialize-from
      (mem/slice segment (mem/size-of ::mem/long))
      (get type-map tag))]))
</code></pre>
<p>Deserialization is a little more complex. First the tag is retrieved from the beginning of the segment, and then the type of the value is decided based on that before it is deserialized.</p>
</div></div></div></body></html>